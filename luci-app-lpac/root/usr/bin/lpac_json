#!/bin/sh
# Copyright 2025 KilimcininKorOglu
# https://github.com/KilimcininKorOglu/luci-lpac-ui
# Licensed under the MIT License
# Wrapper script for lpac - Adapts lpac JSON output for LuCI interface

# Configuration
LPAC_BIN="/usr/bin/lpac"
APDU_DRIVER="${LPAC_APDU:-at}"
AT_DEVICE="${LPAC_APDU_AT_DEVICE:-/dev/ttyUSB2}"
MBIM_DEVICE="${LPAC_APDU_MBIM_DEVICE:-/dev/cdc-wdm0}"
QMI_DEVICE="${LPAC_APDU_QMI_DEVICE:-/dev/cdc-wdm0}"
HTTP_CLIENT="${LPAC_HTTP:-curl}"
TIMEOUT=90

# Lock file for preventing concurrent access
LOCKFILE="/var/run/lpac_json.lock"
LOCKFD=200

# Acquire lock to prevent concurrent lpac operations
acquire_lock() {
    eval "exec $LOCKFD>$LOCKFILE"
    if ! flock -n $LOCKFD 2>/dev/null; then
        echo '{"success": false, "error": "Another lpac operation is in progress. Please wait and try again."}'
        exit 1
    fi
}

# Release lock on exit
release_lock() {
    flock -u $LOCKFD 2>/dev/null
    rm -f "$LOCKFILE" 2>/dev/null
}

# Ensure lock is released on script exit (normal or error)
trap release_lock EXIT INT TERM

# Acquire lock at startup
acquire_lock

# Timeout wrapper function for systems without 'timeout' command (OpenWrt 19.07.10)
run_with_timeout() {
    local timeout_duration="$1"
    shift

    # Check if timeout command exists
    if command -v timeout >/dev/null 2>&1; then
        timeout "$timeout_duration" "$@"
        return $?
    fi

    # Fallback using perl (usually available on OpenWrt)
    if command -v perl >/dev/null 2>&1; then
        perl -e '
            $SIG{ALRM} = sub { kill 9, $pid; exit 124; };
            alarm shift @ARGV;
            $pid = fork();
            if ($pid == 0) {
                exec @ARGV;
                exit 1;
            }
            waitpid($pid, 0);
            alarm 0;
            exit($? >> 8);
        ' "$timeout_duration" "$@"
        return $?
    fi

    # Last resort: Run without timeout and log warning
    logger -t lpac_json "WARNING: No timeout mechanism available, operation may hang indefinitely"
    "$@"
    return $?
}

# Parse command-line options for device override
while getopts "d:t:m:q:h:" opt; do
    case "$opt" in
        d) APDU_DRIVER="$OPTARG" ;;      # Driver: at, at_csim, mbim, qmi, qmi_qrtr, uqmi
        t) AT_DEVICE="$OPTARG" ;;         # AT device (ttyUSB*)
        m) MBIM_DEVICE="$OPTARG" ;;       # MBIM device (cdc-wdm*)
        q) QMI_DEVICE="$OPTARG" ;;        # QMI device (cdc-wdm*)
        h) HTTP_CLIENT="$OPTARG" ;;       # HTTP client: curl, wget
    esac
done
shift $((OPTIND-1))

# Set environment variables for lpac
export LPAC_APDU="$APDU_DRIVER"
export LPAC_HTTP="$HTTP_CLIENT"

case "$APDU_DRIVER" in
    at|at_csim)
        export LPAC_APDU_AT_DEVICE="$AT_DEVICE"
        DEVICE_TO_CHECK="$AT_DEVICE"
        ;;
    mbim)
        export LPAC_APDU_MBIM_DEVICE="$MBIM_DEVICE"
        DEVICE_TO_CHECK="$MBIM_DEVICE"
        ;;
    qmi|uqmi)
        export LPAC_APDU_QMI_DEVICE="$QMI_DEVICE"
        DEVICE_TO_CHECK="$QMI_DEVICE"
        ;;
    qmi_qrtr)
        # QMI QRTR doesn't need a device file - it uses Qualcomm IPC Router
        DEVICE_TO_CHECK=""
        ;;
    *)
        echo "{\"success\": false, \"error\": \"Invalid APDU driver: $APDU_DRIVER. Valid: at, at_csim, mbim, qmi, qmi_qrtr, uqmi\"}"
        exit 1
        ;;
esac

# Function to convert lpac JSON to LuCI-compatible format
convert_lpac_json() {
    local lpac_output="$1"
    local action="$2"

    # lpac can output multiple JSON lines (progress messages + final result)
    # Extract the LAST line that contains "type":"lpa" which is the final result
    local final_line=$(echo "$lpac_output" | grep '"type"[[:space:]]*:[[:space:]]*"lpa"' | tail -1)

    # If no final result found, use the entire output
    if [ -z "$final_line" ]; then
        final_line="$lpac_output"
    fi

    # Extract lpac response fields from the final result line
    local code=$(echo "$final_line" | grep -o '"code"[[:space:]]*:[[:space:]]*[0-9]*' | head -1 | grep -o '[0-9]*$')
    local message=$(echo "$final_line" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"\([^"]*\)".*/\1/')

    # Success if code is 0
    if [ "$code" = "0" ]; then
        # For download/delete/enable/disable/nickname actions, provide clean success message without raw output
        if [ "$action" = "download" ] || [ "$action" = "delete" ] || [ "$action" = "enable" ] || [ "$action" = "disable" ] || [ "$action" = "nickname" ]; then
            echo "{"
            echo "  \"success\": true,"
            echo "  \"message\": \"$([ -n "$message" ] && echo "$message" || echo "Operation completed successfully")\""
            echo "}"
        else
            # For other actions, include output for debugging
            echo "{"
            echo "  \"success\": true,"
            echo "  \"message\": \"$([ -n "$message" ] && echo "$message" || echo "Operation completed successfully")\","
            echo "  \"output\": $(echo "$lpac_output" | sed 's/\\/\\\\/g; s/"/\\"/g; s/^/"/; s/$/"/' | tr -d '\n')"
            echo "}"
        fi
    else
        # Extract error details
        local error_msg="$message"
        if [ -z "$error_msg" ]; then
            error_msg="Operation failed with code: $code"
        fi

        echo "{"
        echo "  \"success\": false,"
        echo "  \"error\": \"$error_msg\""
        echo "}"
    fi
}

# Function to extract profile list from lpac JSON
extract_profiles() {
    local lpac_output="$1"

    # lpac v2.x returns: {"type":"lpa","payload":{"code":0,"message":"success","data":[...]}}
    # Extract code from payload
    local code=$(echo "$lpac_output" | grep -o '"code"[[:space:]]*:[[:space:]]*[0-9-]*' | head -1 | grep -o '[0-9-]*$')

    # If no code found or code is empty, return raw error
    if [ -z "$code" ]; then
        echo "{"
        echo "  \"success\": false,"
        echo "  \"profiles\": [],"
        echo "  \"error\": \"Failed to parse lpac response\","
        echo "  \"raw_output\": \"$(echo "$lpac_output" | sed 's/"/\\"/g' | tr '\n' ' ')\""
        echo "}"
        return
    fi

    if [ "$code" != "0" ]; then
        local message=$(echo "$lpac_output" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"\([^"]*\)".*/\1/')
        echo "{"
        echo "  \"success\": false,"
        echo "  \"profiles\": [],"
        echo "  \"error\": \"${message:-Failed to list profiles} (code: $code)\","
        echo "  \"raw_output\": \"$(echo "$lpac_output" | sed 's/"/\\"/g' | tr '\n' ' ')\""
        echo "}"
        return
    fi

    # Check if data array is empty
    if echo "$lpac_output" | grep -q '"data"[[:space:]]*:[[:space:]]*\[\]'; then
        echo "{"
        echo "  \"success\": true,"
        echo "  \"profiles\": [],"
        echo "  \"message\": \"No profiles installed\""
        echo "}"
        return
    fi

    # Parse profiles from lpac data array
    echo "{"
    echo "  \"success\": true,"
    echo "  \"profiles\": ["

    # Extract ICCID, state, and nickname from each profile
    # lpac v2.x format: "data": [{"iccid": "...", "profileState": "enabled/disabled", "profileNickname": "..."}, ...]
    local first=1
    echo "$lpac_output" | grep -o '"iccid"[[:space:]]*:[[:space:]]*"[^"]*"' | while IFS= read -r iccid_line; do
        ICCID=$(echo "$iccid_line" | sed 's/.*"\([^"]*\)".*/\1/')

        # Try to find state for this ICCID
        STATE="unknown"
        if echo "$lpac_output" | grep -A 10 "$ICCID" | grep -q '"profileState"[[:space:]]*:[[:space:]]*"enabled"'; then
            STATE="enabled"
        elif echo "$lpac_output" | grep -A 10 "$ICCID" | grep -q '"profileState"[[:space:]]*:[[:space:]]*"disabled"'; then
            STATE="disabled"
        fi

        # Extract nickname if present
        NICKNAME=$(echo "$lpac_output" | grep -A 10 "$ICCID" | grep -o '"profileNickname"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"\([^"]*\)".*/\1/' | head -1)

        if [ $first -eq 0 ]; then
            echo "    ,"
        fi
        first=0

        echo "    {"
        echo "      \"iccid\": \"$ICCID\","
        echo "      \"state\": \"$STATE\""
        if [ -n "$NICKNAME" ]; then
            echo "      ,\"nickname\": \"$NICKNAME\""
        fi
        echo "    }"
    done

    echo "  ]"
    echo "}"
}

# Check if lpac binary exists
if [ ! -x "$LPAC_BIN" ]; then
    echo "{\"success\": false, \"error\": \"lpac binary not found at $LPAC_BIN\"}"
    exit 1
fi

# Check if device exists (skip for qmi_qrtr as it doesn't need a device file)
if [ -n "$DEVICE_TO_CHECK" ] && [ ! -e "$DEVICE_TO_CHECK" ]; then
    echo "{\"success\": false, \"error\": \"Device not found at $DEVICE_TO_CHECK\"}"
    exit 1
fi

# Parse action
ACTION="$1"

case "$ACTION" in
    add)
        ACTIVATION_CODE="$2"
        CONFIRMATION_CODE="$3"

        # Validation
        if [ -z "$ACTIVATION_CODE" ]; then
            echo "{\"success\": false, \"error\": \"Activation code is required\"}"
            exit 1
        fi

        # Build lpac command
        # lpac profile download -a 'LPA:...' or -s server -m matching-id [-c confirmation]
        if echo "$ACTIVATION_CODE" | grep -q '^LPA:'; then
            # QR code format
            CMD="$LPAC_BIN profile download -a '$ACTIVATION_CODE'"
        else
            # Assume it's a matching ID, need server
            echo "{\"success\": false, \"error\": \"Invalid activation code format. Use QR code (LPA:...) or provide server and matching ID separately\"}"
            exit 1
        fi

        # Add confirmation code if provided
        if [ -n "$CONFIRMATION_CODE" ]; then
            CMD="$CMD -c '$CONFIRMATION_CODE'"
        fi

        # Execute with timeout
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        # Convert lpac JSON to LuCI format
        convert_lpac_json "$OUTPUT" "download"
        exit 0
        ;;

    delete)
        ICCID="$2"

        # Validation
        if [ -z "$ICCID" ]; then
            echo "{\"success\": false, \"error\": \"ICCID is required\"}"
            exit 1
        fi

        # Build lpac command
        CMD="$LPAC_BIN profile delete '$ICCID'"

        # Execute with timeout
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        # Convert lpac JSON to LuCI format
        convert_lpac_json "$OUTPUT" "delete"
        exit 0
        ;;

    enable)
        ICCID="$2"

        if [ -z "$ICCID" ]; then
            echo "{\"success\": false, \"error\": \"ICCID is required\"}"
            exit 1
        fi

        CMD="$LPAC_BIN profile enable '$ICCID'"
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        convert_lpac_json "$OUTPUT" "enable"
        exit 0
        ;;

    disable)
        ICCID="$2"

        if [ -z "$ICCID" ]; then
            echo "{\"success\": false, \"error\": \"ICCID is required\"}"
            exit 1
        fi

        CMD="$LPAC_BIN profile disable '$ICCID'"
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        convert_lpac_json "$OUTPUT" "disable"
        exit 0
        ;;

    list)
        # List profiles using lpac - lpac v2.x returns proper JSON directly
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN profile list 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"profiles\": []}"
            exit 0
        fi

        # lpac returns: {"type":"lpa","payload":{"code":0,"message":"success","data":[...]}}
        # Check if it's valid JSON with code=0
        if echo "$OUTPUT" | grep -q '"code"[[:space:]]*:[[:space:]]*0'; then
            # Success - return lpac's JSON directly with success wrapper
            echo "{"
            echo "  \"success\": true,"
            echo "  \"profiles\": $(echo "$OUTPUT" | sed -n 's/.*"data"[[:space:]]*:[[:space:]]*\(\[.*\]\).*/\1/p')"
            echo "}"
        else
            # Error
            echo "{\"success\": false, \"error\": \"Failed to list profiles\", \"profiles\": []}"
        fi
        exit 0
        ;;

    info)
        # Get chip info
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN chip info 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\"}"
            exit 0
        fi

        convert_lpac_json "$OUTPUT" "info"
        exit 0
        ;;

    nickname)
        ICCID="$2"
        NICKNAME="$3"

        # Validation
        if [ -z "$ICCID" ]; then
            echo "{\"success\": false, \"error\": \"ICCID is required\"}"
            exit 1
        fi

        # Build lpac command - nickname can be empty to clear it
        CMD="$LPAC_BIN profile nickname '$ICCID' '$NICKNAME'"

        # Execute with timeout
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        # Convert lpac JSON to LuCI format
        convert_lpac_json "$OUTPUT" "nickname"
        exit 0
        ;;

    status)
        # Get chip info as status
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN chip info 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\"}"
            exit 0
        fi

        convert_lpac_json "$OUTPUT" "status"
        exit 0
        ;;

    notification_list)
        # List pending notifications
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN notification list 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"notifications\": []}"
            exit 0
        fi

        # lpac returns: {"type":"lpa","payload":{"code":0,"message":"success","data":[...]}}
        # Extract notifications array similar to profile list
        if echo "$OUTPUT" | grep -q '"code"[[:space:]]*:[[:space:]]*0'; then
            echo "{"
            echo "  \"success\": true,"
            echo "  \"notifications\": $(echo "$OUTPUT" | sed -n 's/.*"data"[[:space:]]*:[[:space:]]*\(\[.*\]\).*/\1/p')"
            echo "}"
        else
            echo "{\"success\": false, \"error\": \"Failed to list notifications\", \"notifications\": []}"
        fi
        exit 0
        ;;

    notification_process_all)
        # Process all pending notifications with auto-remove (-r flag)
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN notification process -a -r 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\"}"
            exit 0
        fi

        # Check if operation succeeded
        if echo "$OUTPUT" | grep -q '"code"[[:space:]]*:[[:space:]]*0'; then
            # Count how many notifications were processed
            NOTIFICATION_COUNT=$(echo "$OUTPUT" | grep -o '"seqNumber"' | wc -l)
            echo "{"
            echo "  \"success\": true,"
            echo "  \"message\": \"Processed and removed $NOTIFICATION_COUNT notification(s)\","
            echo "  \"count\": $NOTIFICATION_COUNT"
            echo "}"
        else
            # Check if there were no notifications to process
            if echo "$OUTPUT" | grep -qi "no.*notification" || echo "$OUTPUT" | grep -q '"data"[[:space:]]*:[[:space:]]*\[\]'; then
                echo "{"
                echo "  \"success\": true,"
                echo "  \"message\": \"No pending notifications to process\","
                echo "  \"count\": 0"
                echo "}"
            else
                # Actual error
                local error_msg=$(echo "$OUTPUT" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"\([^"]*\)".*/\1/' | head -1)
                echo "{"
                echo "  \"success\": false,"
                echo "  \"error\": \"${error_msg:-Failed to process notifications}\""
                echo "}"
            fi
        fi
        exit 0
        ;;

    *)
        echo "{\"success\": false, \"error\": \"Invalid action: $ACTION. Valid actions: add, delete, enable, disable, list, info, status, nickname, notification_list, notification_process_all\"}"
        exit 1
        ;;
esac
