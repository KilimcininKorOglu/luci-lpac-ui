#!/bin/sh
# Copyright 2025 KilimcininKorOglu
# https://github.com/KilimcininKorOglu/luci-lpac-ui
# Licensed under the MIT License
# Wrapper script for lpac - Adapts lpac JSON output for LuCI interface

# Configuration
LPAC_BIN="/usr/bin/lpac"
APDU_DRIVER="${LPAC_APDU:-at}"
AT_DEVICE="${LPAC_APDU_AT_DEVICE:-/dev/ttyUSB2}"
MBIM_DEVICE="${LPAC_APDU_MBIM_DEVICE:-/dev/cdc-wdm0}"
QMI_DEVICE="${LPAC_APDU_QMI_DEVICE:-/dev/cdc-wdm0}"
HTTP_CLIENT="${LPAC_HTTP:-curl}"
TIMEOUT=90

# Lock file for preventing concurrent access
LOCKFILE="/var/run/lpac_json.lock"
LOCKFD=200
LOCK_TIMEOUT=120  # 2 minutes - stale lock cleanup threshold

# Acquire lock to prevent concurrent lpac operations
acquire_lock() {
    # Check if lock file exists and is stale (older than LOCK_TIMEOUT)
    if [ -f "$LOCKFILE" ]; then
        LOCK_AGE=$(( $(date +%s) - $(stat -c %Y "$LOCKFILE" 2>/dev/null || echo 0) ))
        if [ "$LOCK_AGE" -gt "$LOCK_TIMEOUT" ]; then
            logger -t lpac_json "Stale lock detected (age: ${LOCK_AGE}s) - killing all lpac and lpac_json processes"
            # Kill all lpac binary processes first
            killall -9 lpac 2>/dev/null
            # Then kill all lpac_json wrapper processes
            killall -9 lpac_json 2>/dev/null
            # Remove stale lock file
            rm -f "$LOCKFILE" 2>/dev/null
            # Small delay to ensure processes are terminated
            sleep 1
        fi
    fi

    eval "exec $LOCKFD>$LOCKFILE"
    if ! flock -n $LOCKFD 2>/dev/null; then
        # Check lock age before giving up
        if [ -f "$LOCKFILE" ]; then
            LOCK_AGE=$(( $(date +%s) - $(stat -c %Y "$LOCKFILE" 2>/dev/null || echo 0) ))
            echo "{\"success\": false, \"error\": \"Another lpac operation is in progress (active for ${LOCK_AGE}s). Please wait and try again.\"}"
        else
            echo '{"success": false, "error": "Another lpac operation is in progress. Please wait and try again."}'
        fi
        exit 1
    fi

    # Update lock file timestamp to track activity
    touch "$LOCKFILE" 2>/dev/null
}

# Release lock on exit
release_lock() {
    flock -u $LOCKFD 2>/dev/null
    rm -f "$LOCKFILE" 2>/dev/null
}

# Ensure lock is released on script exit (normal or error)
trap release_lock EXIT INT TERM

# Acquire lock at startup
acquire_lock

# Timeout wrapper function for systems without 'timeout' command (OpenWrt 19.07.10)
run_with_timeout() {
    local timeout_duration="$1"
    shift

    # Check if timeout command exists
    if command -v timeout >/dev/null 2>&1; then
        timeout "$timeout_duration" "$@"
        return $?
    fi

    # Fallback using perl (usually available on OpenWrt)
    if command -v perl >/dev/null 2>&1; then
        perl -e '
            $SIG{ALRM} = sub { kill 9, $pid; exit 124; };
            alarm shift @ARGV;
            $pid = fork();
            if ($pid == 0) {
                exec @ARGV;
                exit 1;
            }
            waitpid($pid, 0);
            alarm 0;
            exit($? >> 8);
        ' "$timeout_duration" "$@"
        return $?
    fi

    # Last resort: Run without timeout and log warning
    logger -t lpac_json "WARNING: No timeout mechanism available, operation may hang indefinitely"
    "$@"
    return $?
}

# Parse command-line options for device override
while getopts "d:t:m:q:h:" opt; do
    case "$opt" in
        d) APDU_DRIVER="$OPTARG" ;;      # Driver: at, at_csim, mbim, qmi, qmi_qrtr, uqmi
        t) AT_DEVICE="$OPTARG" ;;         # AT device (ttyUSB*)
        m) MBIM_DEVICE="$OPTARG" ;;       # MBIM device (cdc-wdm*)
        q) QMI_DEVICE="$OPTARG" ;;        # QMI device (cdc-wdm*)
        h) HTTP_CLIENT="$OPTARG" ;;       # HTTP client: curl, wget
    esac
done
shift $((OPTIND-1))

# Set environment variables for lpac
export LPAC_APDU="$APDU_DRIVER"
export LPAC_HTTP="$HTTP_CLIENT"

# Workaround for mbedTLS SSL certificate verification issues on OpenWrt
# When curl is compiled with mbedTLS (common on OpenWrt), it may fail to verify
# SM-DP+ server certificates even with ca-bundle installed. Enabling HTTP debug
# mode appears to work around this issue.
export LIBEUICC_DEBUG_HTTP=1

case "$APDU_DRIVER" in
    at|at_csim)
        export LPAC_APDU_AT_DEVICE="$AT_DEVICE"
        DEVICE_TO_CHECK="$AT_DEVICE"
        ;;
    mbim)
        export LPAC_APDU_MBIM_DEVICE="$MBIM_DEVICE"
        DEVICE_TO_CHECK="$MBIM_DEVICE"

        # Check if MBIM device is in use by network interface
        if lsof "$MBIM_DEVICE" 2>/dev/null | grep -q mbim; then
            logger -t lpac_json "WARNING: MBIM device $MBIM_DEVICE is in use by network interface"
            echo "{\"success\": false, \"error\": \"MBIM device is currently in use by network interface. To use eSIM management: 1) Switch to AT driver (recommended - use 'Scan for Devices' in 'Modem Device & Status' section), 2) Temporarily disable network interface (ifdown wwan0), or 3) Use a different modem port if available\"}"
            exit 1
        fi
        ;;
    qmi|uqmi)
        export LPAC_APDU_QMI_DEVICE="$QMI_DEVICE"
        DEVICE_TO_CHECK="$QMI_DEVICE"

        # Check if QMI device is in use by network interface
        if lsof "$QMI_DEVICE" 2>/dev/null | grep -qE "qmi|uqmi"; then
            logger -t lpac_json "WARNING: QMI device $QMI_DEVICE is in use by network interface"
            echo "{\"success\": false, \"error\": \"QMI device is currently in use by network interface. QMI driver cannot be shared between network interface and eSIM management. Solution: 1) Switch to AT driver (recommended - use 'Scan for Devices' in 'Modem Device & Status' section), 2) Temporarily disable network interface: 'ifdown wwan0', perform eSIM operation, then 'ifup wwan0', or 3) Use a different modem port if available\"}"
            exit 1
        fi
        ;;
    qmi_qrtr)
        # QMI QRTR doesn't need a device file - it uses Qualcomm IPC Router
        DEVICE_TO_CHECK=""
        ;;
    *)
        echo "{\"success\": false, \"error\": \"Invalid APDU driver: $APDU_DRIVER. Valid: at, at_csim, mbim, qmi, qmi_qrtr, uqmi\"}"
        exit 1
        ;;
esac

# Function to convert lpac JSON to LuCI-compatible format
convert_lpac_json() {
    local lpac_output="$1"
    local action="$2"

    # lpac can output multiple JSON lines (progress messages + final result)
    # Extract the LAST line that contains "type":"lpa" which is the final result
    local final_line=$(echo "$lpac_output" | grep '"type"[[:space:]]*:[[:space:]]*"lpa"' | tail -1)

    # If no final result found, use the entire output
    if [ -z "$final_line" ]; then
        final_line="$lpac_output"
    fi

    # Extract lpac response fields from the final result line
    # lpac v2.x format: {"type":"lpa","payload":{"code":...,"message":"...","data":"..."}}
    local code=$(echo "$final_line" | grep -o '"code"[[:space:]]*:[[:space:]]*[0-9-]*' | head -1 | grep -o '[0-9-]*$')
    local message=$(echo "$final_line" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"\([^"]*\)".*/\1/')

    # Extract data field - handle both string and object formats
    # Try string format first: "data":"..."
    local data=$(echo "$final_line" | grep -o '"data"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"\([^"]*\)".*/\1/')

    # If data is empty, try to extract full data content (for debugging)
    if [ -z "$data" ]; then
        # Extract everything between "data": and next }
        data=$(echo "$final_line" | sed -n 's/.*"data"[[:space:]]*:[[:space:]]*\([^}]*\).*/\1/p' | sed 's/[,"]$//')
    fi

    # Success if code is 0
    if [ "$code" = "0" ]; then
        # For download/delete/enable/disable/nickname actions, provide clean success message without raw output
        if [ "$action" = "download" ] || [ "$action" = "delete" ] || [ "$action" = "enable" ] || [ "$action" = "disable" ] || [ "$action" = "nickname" ]; then
            echo "{"
            echo "  \"success\": true,"
            echo "  \"message\": \"$([ -n "$message" ] && echo "$message" || echo "Operation completed successfully")\""
            echo "}"
        else
            # For other actions, include output for debugging
            echo "{"
            echo "  \"success\": true,"
            echo "  \"message\": \"$([ -n "$message" ] && echo "$message" || echo "Operation completed successfully")\","
            echo "  \"output\": $(echo "$lpac_output" | sed 's/\\/\\\\/g; s/"/\\"/g; s/^/"/; s/$/"/' | tr -d '\n')"
            echo "}"
        fi
    else
        # Extract error details and combine message + data for better context
        local error_msg="$message"

        # If data field exists and is a string, append it to the error message
        if [ -n "$data" ]; then
            error_msg="$message: $data"
        fi

        if [ -z "$error_msg" ]; then
            error_msg="Operation failed with code: $code"
        fi

        # Create user-friendly error messages for common lpac errors
        case "$message" in
            # ES9P Authentication Errors (SM-DP+ Communication)
            "es9p_initiate_authentication"|"es9p_authenticate_client")
                if echo "$data" | grep -qi "MatchingID is refused"; then
                    error_msg="Activation code rejected - This code is for a different device (EID mismatch). Request a new code from your eSIM provider"
                elif echo "$data" | grep -qi "EID"; then
                    error_msg="EID mismatch - Activation code is for a different device. Request a new code for your modem"
                elif echo "$data" | grep -qi "insufficient.*memory\|not.*enough.*space"; then
                    error_msg="Not enough memory on SIM card - Delete unused profiles to free up space"
                elif echo "$data" | grep -qi "expired\|timeout"; then
                    error_msg="Activation code expired - Request a new code from your eSIM provider"
                elif echo "$data" | grep -qi "Confirmation.*Code"; then
                    error_msg="Confirmation code required or incorrect - Check with your eSIM provider"
                else
                    error_msg="Connection failed - Check activation code or network connection"
                fi
                ;;

            # ES9P Get Profile Package Error
            "es9p_get_bound_profile_package")
                error_msg="Download failed - Check your internet connection"
                ;;

            # Activation Code Format Errors
            "activation_code")
                if [ "$data" = "invalid" ]; then
                    error_msg="Invalid code format - Must start with 'LPA:1\$'"
                else
                    error_msg="Activation code error: $data"
                fi
                ;;

            "matching_id")
                error_msg="Invalid Matching ID - Use only letters, numbers, and dashes"
                ;;

            "confirmation_code")
                if [ "$data" = "required" ]; then
                    error_msg="Confirmation code required - This code needs a PIN"
                else
                    error_msg="Confirmation code error: $data"
                fi
                ;;

            "smdp")
                if [ "$data" = "empty" ]; then
                    error_msg="Server address missing - Enter SM-DP+ address manually"
                else
                    error_msg="Server error: $data"
                fi
                ;;

            # ES10B eUICC Local Operation Errors
            "es10b_get_euicc_challenge_and_info")
                error_msg="Modem communication failed - Check connection and eSIM support"
                ;;

            "es10b_authenticate_server")
                error_msg="Server authentication failed - Server certificate not trusted"
                ;;

            "es10b_prepare_download")
                if echo "$data" | grep -qi "Confirmation.*Code"; then
                    error_msg="Incorrect confirmation code - Check PIN with provider"
                else
                    error_msg="Download preparation failed - Check confirmation code or memory"
                fi
                ;;

            "es10b_load_bound_profile_package")
                # Parse BPP error details
                if echo "$data" | grep -qi "iccid_already_exists"; then
                    error_msg="Profile already exists - Delete old profile first"
                elif echo "$data" | grep -qi "insufficient_memory"; then
                    error_msg="Not enough memory - Delete unused profiles"
                elif echo "$data" | grep -qi "interruption"; then
                    error_msg="Installation interrupted - Try again"
                elif echo "$data" | grep -qi "invalid_signature"; then
                    error_msg="Invalid signature - Profile may be corrupted"
                else
                    error_msg="Installation failed"
                fi
                ;;

            "es8p_meatadata_parse"|"es8p_metadata_parse")
                error_msg="Profile data corrupted - Cannot read profile information"
                ;;

            # ES10A Configuration Errors
            "es10a_get_euicc_configured_addresses")
                error_msg="Cannot read SIM configuration - Check modem connection"
                ;;

            # ES10B Notification Errors
            "es10b_retrieve_notification_list")
                error_msg="Cannot retrieve notifications - Check modem connection"
                ;;

            # APDU Communication Errors
            "APDU")
                error_msg="Modem communication error - Check device path and driver settings"
                ;;

            # Cancellation
            "cancelled")
                error_msg="Operation cancelled"
                ;;
        esac

        echo "{"
        echo "  \"success\": false,"
        echo "  \"error\": \"$error_msg\","
        echo "  \"error_code\": \"$code\""
        echo "}"
    fi
}

# Function to extract profile list from lpac JSON
extract_profiles() {
    local lpac_output="$1"

    # lpac v2.x returns: {"type":"lpa","payload":{"code":0,"message":"success","data":[...]}}
    # Extract code from payload
    local code=$(echo "$lpac_output" | grep -o '"code"[[:space:]]*:[[:space:]]*[0-9-]*' | head -1 | grep -o '[0-9-]*$')

    # If no code found or code is empty, return raw error
    if [ -z "$code" ]; then
        echo "{"
        echo "  \"success\": false,"
        echo "  \"profiles\": [],"
        echo "  \"error\": \"Failed to parse lpac response\","
        echo "  \"raw_output\": \"$(echo "$lpac_output" | sed 's/"/\\"/g' | tr '\n' ' ')\""
        echo "}"
        return
    fi

    if [ "$code" != "0" ]; then
        local message=$(echo "$lpac_output" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"\([^"]*\)".*/\1/')
        echo "{"
        echo "  \"success\": false,"
        echo "  \"profiles\": [],"
        echo "  \"error\": \"${message:-Failed to list profiles} (code: $code)\","
        echo "  \"raw_output\": \"$(echo "$lpac_output" | sed 's/"/\\"/g' | tr '\n' ' ')\""
        echo "}"
        return
    fi

    # Check if data array is empty
    if echo "$lpac_output" | grep -q '"data"[[:space:]]*:[[:space:]]*\[\]'; then
        echo "{"
        echo "  \"success\": true,"
        echo "  \"profiles\": [],"
        echo "  \"message\": \"No profiles installed\""
        echo "}"
        return
    fi

    # Parse profiles from lpac data array
    echo "{"
    echo "  \"success\": true,"
    echo "  \"profiles\": ["

    # Extract ICCID, state, and nickname from each profile
    # lpac v2.x format: "data": [{"iccid": "...", "profileState": "enabled/disabled", "profileNickname": "..."}, ...]
    local first=1
    echo "$lpac_output" | grep -o '"iccid"[[:space:]]*:[[:space:]]*"[^"]*"' | while IFS= read -r iccid_line; do
        ICCID=$(echo "$iccid_line" | sed 's/.*"\([^"]*\)".*/\1/')

        # Try to find state for this ICCID
        STATE="unknown"
        if echo "$lpac_output" | grep -A 10 "$ICCID" | grep -q '"profileState"[[:space:]]*:[[:space:]]*"enabled"'; then
            STATE="enabled"
        elif echo "$lpac_output" | grep -A 10 "$ICCID" | grep -q '"profileState"[[:space:]]*:[[:space:]]*"disabled"'; then
            STATE="disabled"
        fi

        # Extract nickname if present
        NICKNAME=$(echo "$lpac_output" | grep -A 10 "$ICCID" | grep -o '"profileNickname"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"\([^"]*\)".*/\1/' | head -1)

        if [ $first -eq 0 ]; then
            echo "    ,"
        fi
        first=0

        echo "    {"
        echo "      \"iccid\": \"$ICCID\","
        echo "      \"state\": \"$STATE\""
        if [ -n "$NICKNAME" ]; then
            echo "      ,\"nickname\": \"$NICKNAME\""
        fi
        echo "    }"
    done

    echo "  ]"
    echo "}"
}

# Check if lpac binary exists
if [ ! -x "$LPAC_BIN" ]; then
    echo "{\"success\": false, \"error\": \"lpac binary not found at $LPAC_BIN\"}"
    exit 1
fi

# Check if device exists (skip for qmi_qrtr as it doesn't need a device file)
if [ -n "$DEVICE_TO_CHECK" ] && [ ! -e "$DEVICE_TO_CHECK" ]; then
    echo "{\"success\": false, \"error\": \"Device not found at $DEVICE_TO_CHECK\"}"
    exit 1
fi

# Parse action
ACTION="$1"

case "$ACTION" in
    add)
        # Check if manual mode
        if [ "$2" = "manual" ]; then
            # Manual mode: lpac_json add manual <smdp> <matching_id> [confirmation] [imei]
            SMDP_ADDRESS="$3"
            MATCHING_ID="$4"
            CONFIRMATION_CODE="$5"
            IMEI="$6"

            # Validation
            if [ -z "$SMDP_ADDRESS" ]; then
                echo "{\"success\": false, \"error\": \"SM-DP+ address is required\"}"
                exit 1
            fi

            if [ -z "$MATCHING_ID" ]; then
                echo "{\"success\": false, \"error\": \"Matching ID is required\"}"
                exit 1
            fi

            # Build lpac command with separate -s and -m parameters
            CMD="$LPAC_BIN profile download -s '$SMDP_ADDRESS' -m '$MATCHING_ID'"
        else
            # QR code mode: lpac_json add <activation_code> [confirmation] [imei]
            ACTIVATION_CODE="$2"
            CONFIRMATION_CODE="$3"
            IMEI="$4"

            # Validation
            if [ -z "$ACTIVATION_CODE" ]; then
                echo "{\"success\": false, \"error\": \"Activation code is required\"}"
                exit 1
            fi

            # Build lpac command
            # lpac profile download -a 'LPA:...'
            if echo "$ACTIVATION_CODE" | grep -q '^LPA:'; then
                # QR code format
                CMD="$LPAC_BIN profile download -a '$ACTIVATION_CODE'"
            else
                # Assume it's a matching ID, need server
                echo "{\"success\": false, \"error\": \"Invalid activation code format. Use QR code (LPA:...) or switch to manual mode\"}"
                exit 1
            fi
        fi

        # Add confirmation code if provided
        if [ -n "$CONFIRMATION_CODE" ]; then
            CMD="$CMD -c '$CONFIRMATION_CODE'"
        fi

        # Add IMEI if provided
        if [ -n "$IMEI" ]; then
            CMD="$CMD -i '$IMEI'"
        fi

        # Execute with timeout
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        # Convert lpac JSON to LuCI format
        convert_lpac_json "$OUTPUT" "download"
        exit 0
        ;;

    delete)
        ICCID="$2"

        # Validation
        if [ -z "$ICCID" ]; then
            echo "{\"success\": false, \"error\": \"ICCID is required\"}"
            exit 1
        fi

        # Build lpac command
        CMD="$LPAC_BIN profile delete '$ICCID'"

        # Execute with timeout
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        # Convert lpac JSON to LuCI format
        convert_lpac_json "$OUTPUT" "delete"
        exit 0
        ;;

    enable)
        ICCID="$2"

        if [ -z "$ICCID" ]; then
            echo "{\"success\": false, \"error\": \"ICCID is required\"}"
            exit 1
        fi

        CMD="$LPAC_BIN profile enable '$ICCID'"
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        convert_lpac_json "$OUTPUT" "enable"
        exit 0
        ;;

    disable)
        ICCID="$2"

        if [ -z "$ICCID" ]; then
            echo "{\"success\": false, \"error\": \"ICCID is required\"}"
            exit 1
        fi

        CMD="$LPAC_BIN profile disable '$ICCID'"
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        convert_lpac_json "$OUTPUT" "disable"
        exit 0
        ;;

    list)
        # List profiles using lpac - lpac v2.x returns proper JSON directly
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN profile list 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"profiles\": []}"
            exit 0
        fi

        # lpac returns: {"type":"lpa","payload":{"code":0,"message":"success","data":[...]}}
        # Check if it's valid JSON with code=0
        if echo "$OUTPUT" | grep -q '"code"[[:space:]]*:[[:space:]]*0'; then
            # Success - return lpac's JSON directly with success wrapper
            echo "{"
            echo "  \"success\": true,"
            echo "  \"profiles\": $(echo "$OUTPUT" | sed -n 's/.*"data"[[:space:]]*:[[:space:]]*\(\[.*\]\).*/\1/p')"
            echo "}"
        else
            # Error
            echo "{\"success\": false, \"error\": \"Failed to list profiles\", \"profiles\": []}"
        fi
        exit 0
        ;;

    info)
        # Get chip info
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN chip info 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\"}"
            exit 0
        fi

        convert_lpac_json "$OUTPUT" "info"
        exit 0
        ;;

    nickname)
        ICCID="$2"
        NICKNAME="$3"

        # Validation
        if [ -z "$ICCID" ]; then
            echo "{\"success\": false, \"error\": \"ICCID is required\"}"
            exit 1
        fi

        # Build lpac command - nickname can be empty to clear it
        CMD="$LPAC_BIN profile nickname '$ICCID' '$NICKNAME'"

        # Execute with timeout
        OUTPUT=$(eval "run_with_timeout $TIMEOUT $CMD 2>&1")
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"output\": \"$OUTPUT\"}"
            exit 0
        fi

        # Convert lpac JSON to LuCI format
        convert_lpac_json "$OUTPUT" "nickname"
        exit 0
        ;;

    status)
        # Get chip info as status
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN chip info 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\"}"
            exit 0
        fi

        convert_lpac_json "$OUTPUT" "status"
        exit 0
        ;;

    notification_list)
        # List pending notifications
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN notification list 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\", \"notifications\": []}"
            exit 0
        fi

        # lpac returns: {"type":"lpa","payload":{"code":0,"message":"success","data":[...]}}
        # Extract notifications array similar to profile list
        if echo "$OUTPUT" | grep -q '"code"[[:space:]]*:[[:space:]]*0'; then
            echo "{"
            echo "  \"success\": true,"
            echo "  \"notifications\": $(echo "$OUTPUT" | sed -n 's/.*"data"[[:space:]]*:[[:space:]]*\(\[.*\]\).*/\1/p')"
            echo "}"
        else
            echo "{\"success\": false, \"error\": \"Failed to list notifications\", \"notifications\": []}"
        fi
        exit 0
        ;;

    notification_process_all)
        # Process all pending notifications with auto-remove (-r flag)
        OUTPUT=$(run_with_timeout $TIMEOUT $LPAC_BIN notification process -a -r 2>&1)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 124 ]; then
            echo "{\"success\": false, \"error\": \"Operation timed out after ${TIMEOUT}s\"}"
            exit 0
        fi

        # Check if operation succeeded
        if echo "$OUTPUT" | grep -q '"code"[[:space:]]*:[[:space:]]*0'; then
            # Count how many notifications were processed
            NOTIFICATION_COUNT=$(echo "$OUTPUT" | grep -o '"seqNumber"' | wc -l)
            echo "{"
            echo "  \"success\": true,"
            echo "  \"message\": \"Processed and removed $NOTIFICATION_COUNT notification(s)\","
            echo "  \"count\": $NOTIFICATION_COUNT"
            echo "}"
        else
            # Check if there were no notifications to process
            if echo "$OUTPUT" | grep -qi "no.*notification" || echo "$OUTPUT" | grep -q '"data"[[:space:]]*:[[:space:]]*\[\]'; then
                echo "{"
                echo "  \"success\": true,"
                echo "  \"message\": \"No pending notifications to process\","
                echo "  \"count\": 0"
                echo "}"
            else
                # Actual error
                local error_msg=$(echo "$OUTPUT" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"\([^"]*\)".*/\1/' | head -1)
                echo "{"
                echo "  \"success\": false,"
                echo "  \"error\": \"${error_msg:-Failed to process notifications}\""
                echo "}"
            fi
        fi
        exit 0
        ;;

    restart_modem)
        # Modem restart using AT+CFUN commands
        # Usage: lpac_json restart_modem <driver> <at_device> <mbim_device>
        DRIVER="$2"
        AT_DEVICE="$3"
        MBIM_DEVICE="$4"

        # Determine device path based on driver
        if [ "$DRIVER" = "mbim" ] || [ "$DRIVER" = "qmi" ] || [ "$DRIVER" = "qmi_qrtr" ] || [ "$DRIVER" = "uqmi" ]; then
            DEVICE="$MBIM_DEVICE"
        else
            # AT or AT_CSIM
            DEVICE="$AT_DEVICE"
        fi

        # For non-AT drivers, we can't send AT commands directly
        if [ "$DRIVER" != "at" ] && [ "$DRIVER" != "at_csim" ]; then
            echo "{"
            echo "  \"success\": false,"
            echo "  \"error\": \"Modem restart via AT commands only supports AT/AT_CSIM drivers. Current driver: $DRIVER\""
            echo "}"
            exit 0
        fi

        # Validate device exists
        if [ ! -e "$DEVICE" ]; then
            echo "{"
            echo "  \"success\": false,"
            echo "  \"error\": \"Device not found: $DEVICE\""
            echo "}"
            exit 0
        fi

        # Send AT+CFUN=0 (disable radio)
        logger -t lpac_json "Restarting modem on $DEVICE: AT+CFUN=0"
        echo -e "AT+CFUN=0\r" > "$DEVICE" 2>/dev/null
        sleep 2

        # Send AT+CFUN=1 (enable radio)
        logger -t lpac_json "Restarting modem on $DEVICE: AT+CFUN=1"
        echo -e "AT+CFUN=1\r" > "$DEVICE" 2>/dev/null
        sleep 3

        # Wait for modem to stabilize
        logger -t lpac_json "Waiting for modem to stabilize (8 seconds)..."
        sleep 8

        # Verify modem is responding
        echo -e "AT\r" > "$DEVICE" 2>/dev/null
        sleep 1

        echo "{"
        echo "  \"success\": true,"
        echo "  \"message\": \"Modem restarted successfully using AT+CFUN=0/1 soft reset\""
        echo "}"
        exit 0
        ;;

    *)
        echo "{\"success\": false, \"error\": \"Invalid action: $ACTION. Valid actions: add, delete, enable, disable, list, info, status, nickname, notification_list, notification_process_all, restart_modem\"}"
        exit 1
        ;;
esac
